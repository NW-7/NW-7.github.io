# NW-7.github.io

## Лабораторная работа 1. Вариант 8. Вычисление ожидаемого числа потомков  
---

## **Цель работы**  
1. Реализовать алгоритм для расчёта математического ожидания числа потомков с доминантным фенотипом в популяции.  
2. Применить принципы объектно-ориентированного программирования (ООП) для структурирования кода.  
3. Обеспечить читаемость, расширяемость и повторное использование кода.

---

### **Задачи**  
1. Спроектировать класс, инкапсулирующий данные популяции и логику расчётов.  
2. Организовать ввод данных через фабричный метод класса.  
3. Реализовать расчёт ожидаемого значения с учётом вероятностей доминирования для разных типов пар.  
4. Обеспечить вывод результата с заданной точностью.

---

### **Шаги реализации**  

**1. Проектирование класса `Population`**  
- **Инкапсуляция данных**:  
  - Атрибут `counts` хранит количество пар каждого типа.  
  - Константы `DOMINANT_PROBS` (вероятности доминирования) и `OFFSPRING_PER_PAIR` (число потомков на пару) заданы на уровне класса.  

**2. Метод `calculate_expected_dominant`**  
- **Логика расчёта**:  
  - Для каждого типа пар умножает их количество на соответствующую вероятность.  
  - Суммирует результаты и умножает на число потомков от одной пары.  

**3. Фабричный метод `from_input`**  
- **Взаимодействие с пользователем**:  
  - Запрашивает ввод количества пар каждого типа.  
  - Создаёт экземпляр класса с полученными данными.  

**4. Основная программа**  
- Создание объекта популяции через `from_input()`.  
- Вызов метода `calculate_expected_dominant()`.  
- Форматированный вывод результата.

---

### **Пример работы программы**  
**Входные данные:**  
```python
AA-AA pairs: 1  
AA-Aa pairs: 0  
AA-aa pairs: 0  
Aa-Aa pairs: 1  
Aa-aa pairs: 0  
aa-aa pairs: 1  
```

**Вывод:**  
```python
Expected dominant offspring: 3.50000  
```

---

### **Принципы ООП в решении**  
1. **Инкапсуляция**:  
   - Данные (количество пар) и логика (вероятности, расчёты) объединены в классе.  
   - Константы защищены от изменений.  

2. **Разделение ответственности**:  
   - `from_input()` отвечает за ввод данных.  
   - `calculate_expected_dominant()` — за бизнес-логику.  

3. **Расширяемость**:  
   - Легко добавить новые типы пар или изменить вероятности.  
   - Можно внедрить валидацию входных данных без изменения основной логики.

---

#### **Заключение**  
- Задача успешно решена с применением ООП.  
- Код соответствует требованиям:  
  - Читаемость: логика разделена на методы с понятными названиями.  
  - Гибкость: параметры легко модифицировать.  
  - Масштабируемость: добавление новых функций не нарушит существующую структуру.
---


## Лабораторная работа 4 BioPython
### Цель работы
Обработка биологических данных в формате GenBank с использованием библиотеки Biopython:
#### Цель задания 1
Объединение записей CDS двух видов в единый файл.
#### Цель задания 2
Анализ и сортировка последовательностей по GC-составу.
#### Цель задания 3
Трансляция кодирующих областей (CDS) в белковые последовательности.

---

### **Задачи**  
1.1 Соормировать исходный файл формата GenBank.
2.1 Реализовать чтение и парсинг файла формата GenBank.  
2.2. Извлечь последовательности ДНК и их метаданные (ID, описание).  
2.3. Вычислить GC-состав для каждой последовательности.  
4. Найти последовательность с максимальным значением GC.  
5. Оформить вывод результатов в требуемом формате.  

---

### **Инструменты и технологии**  
- **Язык программирования**: Python.  
- **Библиотеки**:  
  - `BioPython` (модуль `SeqIO`) — для чтения и обработки файлов GenBank.  
  - `gc_fraction` — функция для расчёта GC-состава.  
- **Среда разработки**: PyCharm  

---

### **Ход работы**  
#### Задание 1: Формирование исходного файла 
- Загрузка данных:
  - Для двух биологических видов (например, Homo sapiens и Banana bunchy top virus) выполнить поиск на NCBI Nucleotide по запросу *название_вида complete cds*.
  - Выбрать 5 записей для первого вида и нажать кнопку 'Send to'. Воспользоваться буфером обмена Clipboard, чтобы добавить выбранные записи в буфер обмена, содержимое которого потом можно экспортировать единым файлом.
  - Повторить для второго вида
  -Для экспорта всех записей из буфера обмена зайти в буфер обмена, нажать кнопку Send to и провести действия, аналогично описанным выше. Сохранить этот файл под названием "sequence.gb".
- Проверка
  - Убедиться, что итоговый файл содержит не менее 10 CDS (по 5 для каждого вида)
 
 #### Задание 2: GC-составы  
**1. Чтение файла GenBank**  
Использован метод `SeqIO.parse()` из библиотеки Biopython для итеративного чтения записей. Каждая запись содержит:  
- Идентификатор (`id`).  
- Описание (`description`).  
- Последовательность ДНК (`seq`).  

**2. Извлечение последовательностей**
Каждая запись в файле разделена двойным слешем `//`. Нужно разделить файл на отдельные записи по этому разделителю. Для каждой записи:
1. Найти раздел `ORIGIN`.
2. Извлечь строки последовательности, удаляя номера позиций и пробелы.
3. Объединить оставшиеся символы в одну строку.  

**3. Расчёт GC-состава**  
Формула:  
```math 
GC=Amount(G+C)/SequenceLength
```
Для расчёта использована функция `gc_fraction()`, возвращающая долю GC.  

**4. Сортировка и вывод**

После вычисления GC-состава для всех последовательностей необходимо отсортировать их по возрастанию этого значения и вывести в требуемом порядке.

  **Потенциальные сложности:**

1. Корректное извлечение последовательностей из раздела `ORIGIN`.

2. Обработка разных регистров букв (например, `a` vs `A`).

3. Учет всех символов, которые могут присутствовать в последовательности (например, пробелы, переводы строк, цифры).

**Пример кода:**
**calculate_gc:** Вычисляет процент GC для данной последовательности.
**parse_genbank:** Функция читает файл, разделяет его на записи и извлекает последовательности из раздела `ORIGIN`.
```python

def parse_genbank(file_path):

with open(file_path, 'r') as file:

content = file.read()

records = content.split('//\n')  # Разделяем записи по //

sequences = []

for record in records:

if 'ORIGIN' not in record:

continue

# Извлекаем раздел ORIGIN

origin_start = record.find('ORIGIN')

origin_section = record[origin_start:]

# Извлекаем строки последовательности

lines = origin_section.split('\n')[1:]  # Пропускаем строку с ORIGIN

sequence = []

for line in lines:

if line.strip() == '':  # Пропускаем пустые строки

continue

# Удаляем номера позиций и пробелы, оставляем только буквы

seq_part = ''.join([c for c in line if c.isalpha()])

sequence.append(seq_part.upper())  # Приводим к верхнему регистру

full_sequence = ''.join(sequence)

sequences.append(full_sequence)

return sequences

def calculate_gc(sequence):

g = sequence.count('G')

c = sequence.count('C')

total = len(sequence)

return (g + c) / total * 100 if total > 0 else 0.0

# Основной код обрабатывает файл, вычисляет GC-состав для каждой последовательности, сортирует и выводит результат.


file_path = 'sequence.gb.txt'

sequences = parse_genbank(file_path)

# Создаем список кортежей (GC%, последовательность)

gc_sequences = [(calculate_gc(seq), seq) for seq in sequences]

# Сортируем по возрастанию GC%

sorted_sequences = sorted(gc_sequences, key=lambda x: x[0])

# Вывод результатов

for gc, seq in sorted_sequences:

print(f"GC-состав: {gc:.2f}%")

print(f"Последовательность: {seq[:50]}...")  # Выводим первые 50 символов для краткости

print()

```
```
from Bio import SeqIO
from Bio.SeqUtils import gc_fraction

def read_genbank(file_path):
    """Читает файл GenBank и возвращает список записей с GC-составом"""
    records = []
    with open(file_path, "r") as handle:
        for record in SeqIO.parse(handle, "genbank"):
            gc = gc_fraction(record.seq)  # Доля GC без умножения на 100
            description = " ".join(record.description.split())  # Убираем лишние пробелы
            records.append((gc, record.id, description))
    return records

def main():
    file_path = "sequence.gb.txt"
    records = read_genbank(file_path)
    
    # Сортировка по возрастанию GC-состава
    sorted_records = sorted(records, key=lambda x: x[0])
    
    # Вывод в требуемом формате
    for gc_value, seq_id, description in sorted_records:
        print(f"{seq_id}: {description}, GC = {gc_value}")

if __name__ == "__main__":
    main()
```
**Проверка корректности:**

- Убедитесь, что все последовательности из файла корректно извлечены.

- Проверьте, что расчет GC-состава верен (например, для последовательности с 50% GC результат должен быть 50.00%).

**5. Форматирование вывода**  
Результат выводится в формате:  
```
<ID>: <Описание>, GC = <значение>
```  
Значение GC округляется до 6 знаков после запятой.  

---

#### **Пример работы программы**  
**Входные данные** (фрагмент файла GenBank):  
```genbank
LOCUS       JN626959                 419 bp    mRNA    linear   INV 06-DEC-2012
DEFINITION  Nasonia vitripennis clone navitri-4 navitripenicin mRNA, complete cds.
ORIGIN      
        1 ttggtggcat tttcatcggc tagcatcgat cattctgtag aacagcag...
```  

**Вывод**:  
```
JN626959.1: Nasonia vitripennis clone navitri-4 navitripenicin mRNA, complete cds, GC = 42.506937
```  

---

#### **Выводы**  
1. Задача успешно решена с использованием библиотеки Biopython, что упростило обработку биологических данных.  
2. Код эффективно работает с файлами GenBank любого размера благодаря итеративному чтению.  
3. Решение можно расширить для анализа других параметров (например, длины последовательностей).  
4. Использование ООП позволило бы улучшить структуру кода (например, создать класс `Sequence` с атрибутами `id`, `description`, `gc`).  

--- 
