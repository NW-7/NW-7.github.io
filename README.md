# NW-7.github.io

## Лабораторная работа 1. Вариант 8. Вычисление ожидаемого числа потомков  
---

## **Цель работы**  
1. Реализовать алгоритм для расчёта математического ожидания числа потомков с доминантным фенотипом в популяции.  
2. Применить принципы объектно-ориентированного программирования (ООП) для структурирования кода.  
3. Обеспечить читаемость, расширяемость и повторное использование кода.

---

### **Задачи**  
1. Спроектировать класс, инкапсулирующий данные популяции и логику расчётов.  
2. Организовать ввод данных через фабричный метод класса.  
3. Реализовать расчёт ожидаемого значения с учётом вероятностей доминирования для разных типов пар.  
4. Обеспечить вывод результата с заданной точностью.

---

### **Шаги реализации**  

**1. Проектирование класса `Population`**  
- **Инкапсуляция данных**:  
  - Атрибут `counts` хранит количество пар каждого типа.  
  - Константы `DOMINANT_PROBS` (вероятности доминирования) и `OFFSPRING_PER_PAIR` (число потомков на пару) заданы на уровне класса.  

**2. Метод `calculate_expected_dominant`**  
- **Логика расчёта**:  
  - Для каждого типа пар умножает их количество на соответствующую вероятность.  
  - Суммирует результаты и умножает на число потомков от одной пары.  

**3. Фабричный метод `from_input`**  
- **Взаимодействие с пользователем**:  
  - Запрашивает ввод количества пар каждого типа.  
  - Создаёт экземпляр класса с полученными данными.  

**4. Основная программа**  
- Создание объекта популяции через `from_input()`.  
- Вызов метода `calculate_expected_dominant()`.  
- Форматированный вывод результата.

---

### **Пример работы программы**  
**Входные данные:**  
```python
AA-AA pairs: 1  
AA-Aa pairs: 0  
AA-aa pairs: 0  
Aa-Aa pairs: 1  
Aa-aa pairs: 0  
aa-aa pairs: 1  
```

**Вывод:**  
```python
Expected dominant offspring: 3.50000  
```

---

### **Принципы ООП в решении**  
1. **Инкапсуляция**:  
   - Данные (количество пар) и логика (вероятности, расчёты) объединены в классе.  
   - Константы защищены от изменений.  

2. **Разделение ответственности**:  
   - `from_input()` отвечает за ввод данных.  
   - `calculate_expected_dominant()` — за бизнес-логику.  

3. **Расширяемость**:  
   - Легко добавить новые типы пар или изменить вероятности.  
   - Можно внедрить валидацию входных данных без изменения основной логики.

---

#### **Заключение**  
- Задача успешно решена с применением ООП.  
- Код соответствует требованиям:  
  - Читаемость: логика разделена на методы с понятными названиями.  
  - Гибкость: параметры легко модифицировать.  
  - Масштабируемость: добавление новых функций не нарушит существующую структуру.
---


## Лабораторная работа 4 BioPython
### Цель работы


#### **Цель второго задания**  
Определить последовательность с максимальным GC-составом из файла GenBank, содержащего данные о геномах организмов. Результат должен включать идентификатор последовательности и значение GC-состава с заданной точностью.

---

#### **Задачи**  
0. Соормировать исходный файл формата GenBank.
1. Реализовать чтение и парсинг файла формата GenBank.  
2. Извлечь последовательности ДНК и их метаданные (ID, описание).  
3. Вычислить GC-состав для каждой последовательности.  
4. Найти последовательность с максимальным значением GC.  
5. Оформить вывод результатов в требуемом формате.  

---

#### **Инструменты и технологии**  
- **Язык программирования**: Python.  
- **Библиотеки**:  
  - `BioPython` (модуль `SeqIO`) — для чтения и обработки файлов GenBank.  
  - `gc_fraction` — функция для расчёта GC-состава.  
- **Среда разработки**: PyCharm  

---

#### **Ход работы**  

**1. Чтение файла GenBank**  
Использован метод `SeqIO.parse()` из библиотеки Biopython для итеративного чтения записей. Каждая запись содержит:  
- Идентификатор (`id`).  
- Описание (`description`).  
- Последовательность ДНК (`seq`).  

**2. Извлечение данных**  
Для каждой записи:  
- Последовательность преобразована в строку в верхнем регистре.  
- Удалены пробелы и символы переноса строки.  

**3. Расчёт GC-состава**  
Формула:  
\[
\text{GC\%} = \frac{\text{Количество символов G и C}}{\text{Общая длина последовательности}} \times 100
\]  
Для расчёта использована функция `gc_fraction()`, возвращающая долю GC.  

**4. Поиск максимума**  
- Инициализированы переменные `max_gc` и `max_id`.  
- Для каждой последовательности значение GC сравнивается с текущим максимумом.  

**5. Форматирование вывода**  
Результат выводится в формате:  
```
<ID>: <Описание>, GC = <значение>
```  
Значение GC округляется до 6 знаков после запятой.  

---

#### **Пример работы программы**  
**Входные данные** (фрагмент файла GenBank):  
```genbank
LOCUS       JN626959                 419 bp    mRNA    linear   INV 06-DEC-2012
DEFINITION  Nasonia vitripennis clone navitri-4 navitripenicin mRNA, complete cds.
ORIGIN      
        1 ttggtggcat tttcatcggc tagcatcgat cattctgtag aacagcag...
```  

**Вывод**:  
```
JN626959.1: Nasonia vitripennis clone navitri-4 navitripenicin mRNA, complete cds, GC = 42.506937
```  

---

#### **Выводы**  
1. Задача успешно решена с использованием библиотеки Biopython, что упростило обработку биологических данных.  
2. Код эффективно работает с файлами GenBank любого размера благодаря итеративному чтению.  
3. Решение можно расширить для анализа других параметров (например, длины последовательностей).  
4. Использование ООП позволило бы улучшить структуру кода (например, создать класс `Sequence` с атрибутами `id`, `description`, `gc`).  

--- 
