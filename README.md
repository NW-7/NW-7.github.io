# NW-7.github.io

## Лабораторная работа 1. Вариант 8. Вычисление ожидаемого числа потомков  
---

## **Цель работы**  
1. Реализовать алгоритм для расчёта математического ожидания числа потомков с доминантным фенотипом в популяции.  
2. Применить принципы объектно-ориентированного программирования (ООП) для структурирования кода.  
3. Обеспечить читаемость, расширяемость и повторное использование кода.

---

### **Задачи**  
1. Спроектировать класс, инкапсулирующий данные популяции и логику расчётов.  
2. Организовать ввод данных через фабричный метод класса.  
3. Реализовать расчёт ожидаемого значения с учётом вероятностей доминирования для разных типов пар.  
4. Обеспечить вывод результата с заданной точностью.

---

### **Шаги реализации**  

**1. Проектирование класса `Population`**  
- **Инкапсуляция данных**:  
  - Атрибут `counts` хранит количество пар каждого типа.  
  - Константы `DOMINANT_PROBS` (вероятности доминирования) и `OFFSPRING_PER_PAIR` (число потомков на пару) заданы на уровне класса.  

**2. Метод `calculate_expected_dominant`**  
- **Логика расчёта**:  
  - Для каждого типа пар умножает их количество на соответствующую вероятность.  
  - Суммирует результаты и умножает на число потомков от одной пары.  

**3. Фабричный метод `from_input`**  
- **Взаимодействие с пользователем**:  
  - Запрашивает ввод количества пар каждого типа.  
  - Создаёт экземпляр класса с полученными данными.  

**4. Основная программа**  
- Создание объекта популяции через `from_input()`.  
- Вызов метода `calculate_expected_dominant()`.  
- Форматированный вывод результата.

---

### **Пример работы программы**  
**Входные данные:**  
```python
AA-AA pairs: 1  
AA-Aa pairs: 0  
AA-aa pairs: 0  
Aa-Aa pairs: 1  
Aa-aa pairs: 0  
aa-aa pairs: 1  
```

**Вывод:**  
```python
Expected dominant offspring: 3.50000  
```

---

### **Принципы ООП в решении**  
1. **Инкапсуляция**:  
   - Данные (количество пар) и логика (вероятности, расчёты) объединены в классе.  
   - Константы защищены от изменений.  

2. **Разделение ответственности**:  
   - `from_input()` отвечает за ввод данных.  
   - `calculate_expected_dominant()` — за бизнес-логику.  

3. **Расширяемость**:  
   - Легко добавить новые типы пар или изменить вероятности.  
   - Можно внедрить валидацию входных данных без изменения основной логики.

---

#### **Заключение**  
- Задача успешно решена с применением ООП.  
- Код соответствует требованиям:  
  - Читаемость: логика разделена на методы с понятными названиями.  
  - Гибкость: параметры легко модифицировать.  
  - Масштабируемость: добавление новых функций не нарушит существующую структуру.
---
## Лабораторная работа 2: РАБОТА С ФАЙЛАМИ В PYTHON  Вариант 1. Вычисление GC-состава
### Цель
Нахождение последовательности ДНК с наибольшим GC-составом в формате FASTA
### Задачи
1. Разделить входные данные на записи, каждая из которых начинается с '>'.
2. Для каждой записи извлечь идентификатор и последовательность ДНК.
3. Для каждой последовательности посчитать GC-состав.
4. Найти запись с максимальным GC-составом.
5. Вывести идентификатор и процент с точностью до шести знаков, как в примере
### Ход работы
**Чтение данных:** Используется sys.stdin.read() для получения всех входных данных.

**Разделение записей:** Данные делятся по символу >, после чего игнорируется пустая строка перед первой записью.

**Обработка записей:**

**Идентификатор:** Извлекается из первой строки записи.

**Последовательность ДНК:** Объединяется из оставшихся строк, удаляются пробелы и переводы строк. Регистр символов приводится к верхнему для универсальности.

**Расчет GC-состава:** Функция calculate_gc считает количество символов G и C, вычисляет их долю в процентах.

**Поиск максимума:** Сравнивается GC-состав всех последовательностей, сохраняется максимальное значение и соответствующий идентификатор.

**Вывод:** Результат форматируется до шести знаков после запятой.

``` python
import sys

def calculate_gc(sequence):
    gc = sequence.count('G') + sequence.count('C')
    total = len(sequence)
    return (gc / total) * 100 if total > 0 else 0.0

def main():
    # Проверяем, есть ли аргументы командной строки
    if len(sys.argv) > 1:
        # Чтение из файла
        filename = sys.argv[1]
        with open(filename, 'r') as file:
            content = file.read().strip()
    else:
        # Чтение из stdin
        content = sys.stdin.read().strip()
    
    records = content.split('>')[1:]
    
    max_gc = -1.0
    max_id = ""
    
    for record in records:
        lines = record.split('\n')
        header = lines[0].strip()
        sequence = ''.join(line.strip().upper() for line in lines[1:] if line.strip())
        
        gc_percent = calculate_gc(sequence)
        
        if gc_percent > max_gc:
            max_gc = gc_percent
            max_id = header
    
    print(max_id)
    print(f"{max_gc:.6f}")

if __name__ == "__main__":
    main()
```
### Вывод
+ sys.stdin.read() не требует указания имени файла — данные читаются из стандартного ввода.
+ Для чтения из конкретного файла используtncz sys.argv и open().
+ Универсальный код обрабатывает оба сценария.


---
## Лабораторная работа 3: ПРЕДСТАВЛЕНИЕ ДАННЫХ В PYTHON
### Цель работы
Освоение методов визуализации данных в Python с использованием библиотеки matplotlib и дополнительных инструментов (seaborn, statsmodels):
1. Построение диаграммы рассеяния для анализа взаимосвязи между признаками с цветовой дифференциацией классов.
2. Создание графиков временных рядов для изучения динамики изменений данных.

### Задания

### Задание 1. Диаграмма рассеяния

#### 1. **Установка необходимых библиотек** -- инструменты
Для работы с данными и визуализацией потребуются:
- `scikit-learn` (для загрузки набора данных `breast_cancer`),
- `pandas` (для работы с табличными данными),
- `matplotlib` или `seaborn` (для построения графиков).
#### 2. **Загрузка данных**
Набор данных `breast_cancer` содержит информацию о опухолях молочной железы.  
**Структура данных:**
- **Факторы (признаки):** `mean radius`, `mean texture` и другие (30 числовых признаков).
- **Целевая переменная (`target`):** 
  - `0` — злокачественная опухоль (malignant),
  - `1` — доброкачественная опухоль (benign).

**Код для загрузки данных:**
```python
from sklearn.datasets import load_breast_cancer
import pandas as pd

# Загрузка данных
data = load_breast_cancer()
df = pd.DataFrame(data.data, columns=data.feature_names)

# Добавляем целевую переменную (классы) в таблицу
df['target'] = data.target

# Выводим первые 5 строк таблицы
print(df.head())
```

---

#### 3. **Просмотр данных**
- **Проверка столбцов:**
  ```python
  print("Столбцы таблицы:", df.columns.tolist())
  ```
  Убедитесь, что в списке есть `mean radius`, `mean texture` и `target`.

- **Описание данных:**
  ```python
  print(data.DESCR)  # Выводит описание набора данных
  ```

- **Статистика по данным:**
  ```python
  print(df[['mean radius', 'mean texture', 'target']].describe())
  ```

#### Код для построения диаграммы рассеяния

#### 1. **Импорт библиотек**
```python
import matplotlib.pyplot as plt
import seaborn as sns
```
#### 2. **Построение графика**
```python
# Настройка стиля
sns.set_style("whitegrid")

# Создание диаграммы рассеяния с цветовым кодированием
plt.figure(figsize=(10, 6))
sns.scatterplot(
    x='mean radius', 
    y='mean texture', 
    hue='target', 
    data=df, 
    palette={0: 'red', 1: 'green'},  # Цвета для классов
    alpha=0.7  # Прозрачность маркеров
)

# Подписи осей и заголовок
plt.xlabel('Mean Radius')
plt.ylabel('Mean Texture')
plt.title('Диаграмма рассеяния: Mean Radius vs Mean Texture')

# Легенда
plt.legend(title='Class', labels=['Malignant (0)', 'Benign (1)'])

# Отображение графика
plt.show()
```
#### Результат - график, где
- **Ось X:** Средний радиус опухоли (`mean radius`),
- **Ось Y:** Средняя текстура опухоли (`mean texture`),
- **Красные точки:** Злокачественные опухоли (класс `0`),
- **Зеленые точки:** Доброкачественные опухоли (класс `1`).
#### Алгоритм:
 - Использование sns.scatterplot с параметрами:
---
### Задание 2. График временных рядов

### Решение задания 2: Построение графика динамики временных рядов

#### 1. **Импорт библиотек и загрузка данных**
Для работы с данными и визуализацией потребуются:
- `statsmodels` (для загрузки набора данных `copper`),
- `pandas` (для работы с табличными данными),
- `matplotlib` (для построения графиков).

```python
import statsmodels.api as sm
import pandas as pd
import matplotlib.pyplot as plt

# Загрузка набора данных 'copper'
data = sm.datasets.copper.load_pandas()
df = data.data  # Получаем DataFrame
```

---

#### 2. **Просмотр данных**
Проверим структуру данных и доступные столбцы:
```python
print("Столбцы таблицы:", df.columns.tolist())
print("\nПервые 5 строк данных:")
print(df.head())
```

Вывод должен показать наличие столбцов:
- `WORLDCONSUMPTION` (мировое потребление меди),
- `COPPERPRICE` (цена на медь),
- `ALUMPRICE` (цена на алюминий),
- `TIME` (временная метка, например, год).
![image](https://github.com/user-attachments/assets/f71cd6c6-aa09-4fb8-8a5b-4705354c8fb9)

---

#### 3. **Фильтрация данных за 1961–1970 годы**
```python
# Добавление столбца`YEAR` со значениями 1951-1960 
df = df.assign(YEAR = df.TIME + 1950)
# Фильтрация данных по годам
filtered_df = df[(df['YEAR'] >= 1961) & (df['YEAR'] <= 1970)]

# Проверка
print("Данные за 1961–1970 годы:")
print(filtered_df[['YEAR', 'WORLDCONSUMPTION', 'COPPERPRICE', 'ALUMPRICE']])
```

---

#### 4. **Построение графика**
Используем `matplotlib` для визуализации временных рядов:

```python
import statsmodels.api as sm
import pandas as pd
import matplotlib.pyplot as plt

# Загрузка данных
data = sm.datasets.copper.load_pandas()
df = data.data

# Фильтрация данных за 1961–1970 годы
filtered_df = df[(df['YEAR'] >= 1961) & (df['YEAR'] <= 1970)]

# Создание фигуры с двумя субплoтами
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

# --- График 1: Мировое потребление меди ---
ax1.plot(
    filtered_df['YEAR'], 
    filtered_df['WORLDCONSUMPTION'], 
    label='Мировое потребление (тыс. тонн)', 
    color='blue', 
    marker='o',
    linestyle='-'
)

# Настройки для первого графика
ax1.set_title('Динамика мирового потребления меди (1961–1970)', fontsize=14)
ax1.set_xlabel('Год', fontsize=12)
ax1.set_ylabel('Потребление, тыс. тонн', fontsize=12)
ax1.grid(True, linestyle='--', alpha=0.7)
ax1.legend()
ax1.set_xticks(filtered_df['YEAR'])

# --- График 2: Цены на медь и алюминий ---
ax2.plot(
    filtered_df['YEAR'], 
    filtered_df['COPPERPRICE'], 
    label='Цена на медь ($/тонн)', 
    color='green', 
    marker='s',
    linestyle='--'
)

ax2.plot(
    filtered_df['YEAR'], 
    filtered_df['ALUMPRICE'], 
    label='Цена на алюминий ($/тонн)', 
    color='red', 
    marker='^',
    linestyle='-.'
)

# Настройки для второго графика
ax2.set_title('Динамика цен на медь и алюминий (1961–1970)', fontsize=14)
ax2.set_xlabel('Год', fontsize=12)
ax2.set_ylabel('Цена, $/тонн', fontsize=12)
ax2.grid(True, linestyle='--', alpha=0.7)
ax2.legend()
ax2.set_xticks(filtered_df['YEAR'])

# Общие настройки
plt.tight_layout()  # Автоматическое выравнивание
plt.show()
```
---

#### **Результат**
![Uploading image.png…]()

Первый график:
- Синяя линия: Мировое потребление меди.
Второй график:
- Зеленая линия: Цена на медь.
- Красная линия: Цена на алюминий.




### Инструменты

####Библиотеки:
matplotlib.pyplot — базовые функции визуализации.
seaborn — улучшенные стили графиков (для диаграммы рассеяния).
statsmodels.datasets — загрузка стандартных наборов данных (Китай, Нил).
pandas — обработка и фильтрация данных.

####Алгоритмы:
Для диаграммы рассеяния:
 - Использование sns.scatterplot с параметрами:
---
## Лабораторная работа 4 BioPython
### Цель работы
Обработка биологических данных в формате GenBank с использованием библиотеки Biopython:
#### Цель задания 1
Объединение записей CDS двух видов в единый файл.
#### Цель задания 2
Анализ и сортировка последовательностей по GC-составу.
#### Цель задания 3
Извлечение нужной информации из файла формата GenBank.

---

### **Задачи**  
#### **Первого задания:**
1. Соормировать исходный файл формата GenBank. 
#### **Второго задания:**
1. Реализовать чтение и парсинг файла формата GenBank.  
2. Извлечь последовательности ДНК и их метаданные (ID, описание).  
3. Вычислить GC-состав для каждой последовательности.  
4. Oтсортировать их по возрастанию этого значения.
5. Оформить вывод результатов в требуемом формате.
#### **Третьего задания:**
1. Реализовать чтение и парсинг файла формата GenBank.  
2. Извлечь метаданные последовательностей ДНК (ID, описание, продукт трянсляции).
3. Оформить вывод результатов в требуемом формате.

---

### **Инструменты и технологии**  
- **Язык программирования**: Python.  
- **Библиотеки**:  
  - `BioPython` (модуль `SeqIO`) — для чтения и обработки файлов GenBank.  
  - `gc_fraction` — функция для расчёта GC-состава.  
- **Среда разработки**: PyCharm  

---

### **Ход работы**  
#### Задание 1: Формирование исходного файла 
- Загрузка данных:
  - Для двух биологических видов (например, Homo sapiens и Banana bunchy top virus) выполнить поиск на NCBI Nucleotide по запросу *название_вида complete cds*.
  - Выбрать 5 записей для первого вида и нажать кнопку 'Send to'. Воспользоваться буфером обмена Clipboard, чтобы добавить выбранные записи в буфер обмена, содержимое которого потом можно экспортировать единым файлом.
  - Повторить для второго вида
  -Для экспорта всех записей из буфера обмена зайти в буфер обмена, нажать кнопку Send to и провести действия, аналогично описанным выше. Сохранить этот файл под названием "sequence.gb".
- Проверка
  - Убедиться, что итоговый файл содержит не менее 10 CDS (по 5 для каждого вида)
 
 #### Задание 2: GC-составы  
**1. Чтение файла GenBank**  
Использован метод `SeqIO.parse()` из библиотеки Biopython для итеративного чтения записей. Каждая запись содержит:  
- Идентификатор (`id`).  
- Описание (`description`).  
- Последовательность ДНК (`seq`).  

**2. Извлечение последовательностей**
Каждая запись в файле разделена двойным слешем `//`. Нужно разделить файл на отдельные записи по этому разделителю. Для каждой записи:
1. Найти раздел `ORIGIN`.
2. Извлечь строки последовательности, удаляя номера позиций и пробелы.
3. Объединить оставшиеся символы в одну строку.  

**3. Расчёт GC-состава**  
Формула:  
```math 
GC=Amount(G+C)/SequenceLength
```
Для расчёта использована функция `gc_fraction()`, возвращающая долю GC.  

**4. Сортировка и вывод**

После вычисления GC-состава для всех последовательностей необходимо отсортировать их по возрастанию этого значения и вывести в требуемом порядке.

  **Потенциальные сложности:**

1. Корректное извлечение последовательностей из раздела `ORIGIN`.

2. Обработка разных регистров букв (например, `a` vs `A`).

3. Учет всех символов, которые могут присутствовать в последовательности (например, пробелы, переводы строк, цифры).

**Пример кода:**
**calculate_gc:** Вычисляет процент GC для данной последовательности.
**parse_genbank:** Функция читает файл, разделяет его на записи и извлекает последовательности из раздела `ORIGIN`.
```python
from Bio import SeqIO
from Bio.SeqUtils import gc_fraction


def read_genbank(file_path):
    records = []
    with open(file_path, "r") as handle:
        for record in SeqIO.parse(handle, "genbank"):
            sequence = str(record.seq).upper()  # Последовательность в верхнем регистре
            gc = gc_fraction(sequence)
            description = " ".join(record.description.split())            
            records.append((gc, sequence, record.id,description))
    return records


def main():
    file_path = "sequence.gb.txt"
    records = read_genbank(file_path)

    # Сортировка по возрастанию GC-состава
    sorted_records = sorted(records, key=lambda x: x[0])

    # Вывод результатов
    for gc, seq, seq_id, description in sorted_records:
        print(f"{seq_id}: {description}, GC = {gc}")
        print(f"Последовательность (первые 50 символов): {seq[:50]}...\n")
        
if __name__ == "__main__":
    main()
```
**Проверка корректности:**

- Убедиться, что все последовательности из файла корректно извлечены.

- Проверить, что расчет GC-состава верен (например, для последовательности с 50% GC результат должен быть 50.00%).

#### Задание 3: Трансляция
1. Прочитать файл GenBank и извлечь все записи.
2. Для каждой записи найти все CDS.
3. Для каждого CDS определить местоположение и направление (плюс или минус цепь).
4. Извлечь готовые translation из блока FEATURES
**Kод, который использует готовые переводы из блока FEATURES:**

```python
from Bio import SeqIO
from Bio.SeqFeature import CompoundLocation

def format_location(feature):
    """Форматирует локацию в стиле GenBank"""
    if isinstance(feature.location, CompoundLocation):
        parts = [f"{part.start+1}:{part.end}" for part in feature.location.parts]
        return f"join({', '.join(parts)})"
    return f"{feature.location.start+1}:{feature.location.end}"

def get_translation(feature):
    """Извлекает перевод из квалификаторов или возвращает None"""
    translation = feature.qualifiers.get("translation", [None])[0]
    
    if translation:
        # Объединяем многострочные переводы и удаляем пробелы
        return "".join(translation.split())
    return None

def main():
    for record in SeqIO.parse("sequence.gb.txt", "genbank"):
        print(f"{record.id}: {record.description}")
        
        for i, feature in enumerate(record.features, 1):
            if feature.type == "CDS":
                # Извлекаем информацию из квалификаторов
                strand = "+" if feature.location.strand >= 0 else "-"
                protein_id = feature.qualifiers.get("protein_id", ["unknown"])[0]
                product = feature.qualifiers.get("product", ["unknown"])[0]
                
                # Получаем готовый перевод или вычисляем
                translation = get_translation(feature)
                
                print(f"\nCDS {i}: {product} (Protein ID: {protein_id})")
                print(f"Location: [{format_location(feature)}]({strand})")
                print(f"Translation:\n{translation}\n")

if __name__ == "__main__":
    main()
```

Пример вывода для одной из записей:
```
JN626959.1: Nasonia vitripennis clone navitri-4 navitripenicin mRNA, complete cds

CDS 1: navitripenicin (Protein ID: AEO53066.1)
Location: [1:324](+)
Translation:
MVAFSSAASIDHSVEQQSIADHSEEQIIYVDGVPVNEIVRRTLRSGNGKITFEVKNEGGQTSFTVNGEAKVWSSKNGYVSVTGGVHQPIGGDAKGHVGVKGEFEWRK
```

##### Ключевые особенности:
1. Извлечение информации напрямую из полей GenBank:
   - `translation` - готовая белковая последовательность
   - `protein_id` - идентификатор белка
   - `product` - название белка

2. Форматирование сложных локаций (join-операторы)

3. Обработка многострочных переводов (удаление пробелов и объединение строк)

4. Отображение дополнительной метаинформации о белке

#### **Выводы**  
1. Задача успешно решена с использованием библиотеки Biopython, что упростило обработку биологических данных.  
2. Код эффективно работает с файлами GenBank любого размера благодаря итеративному чтению.  
3. Использование ООП позволило бы улучшить структуру кода (например, создать класс `Sequence` с атрибутами `id`, `description`, `gc`).  

--- 
